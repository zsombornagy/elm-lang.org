<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
body { font-family: helvetica, arial, sans-serif; }
a:link {text-decoration: none; color: rgb(15,102,230);}
a:visited {text-decoration: none}
a:active {text-decoration: none}
a:hover {text-decoration: underline; color: rgb(234,21,122);}
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  </style>
</head>
<body>
<div style="width:600px;margin:0 auto;">
<p style="text-align:right"><a href="/">Home</a></p>
<h1 id="making-games-in-elm-part-0-pong">Making Games in Elm, Part 0: Pong</h1>
<p>This series has two major goals:</p>
<ol style="list-style-type: decimal">
<li>Get you thinking about <a href="/learn/What-is-FRP.elm" title="Functional Reactive Programming">Functional Reactive Programming</a> (FRP) for games.</li>
<li>Teach you how to make games with Elm.</li>
</ol>
<p>In this post we will be looking into <a href="/edit/examples/Intermediate/Pong.elm">Pong in Elm</a>: a functional game written in Elm, playable in any modern browser.</p>
<h2 id="functional-game-design">Functional Game Design</h2>
<p>Making games is historically a very imperative undertaking, so it has long missed the benefits of purely functional programming. FRP makes it possible to program rich user interactions without resorting to traditional imperative idioms.</p>
<p>By the end of this post we will have written an entire GUI/game without any imperative code. No global mutable state, no flipping pixels, no destructive updates. In fact, Elm disallows all of these things at the language level. So good design and safe coding practices are a requirement, not just self-inforced suggestions.</p>
<p>Imperative programs allow you to reach into objects and data structures whenever you want, so it is not a huge deal if your code is somewhat disorganized. With functional game design, we must be more careful about how our programs are structured. In fact in Elm, all games will share the same underlying structure.</p>
<p>The structure of Elm games breaks into three major parts: modeling the game, updating the game, and viewing the game. It may be helpful to think of it as a functional variation on the Model-View-Controller paradigm.</p>
<p>To make this more concrete, lets see how Pong needs to be structured:</p>
<ol style="list-style-type: decimal">
<li><strong>Model:</strong> First we need to define Pong. We do this by modelling Pong with simple data structures. We need two categories of model:
<ul>
<li>Inputs to the game. For Pong, this is keyboard input from users and clock-ticks from the frame rate manager.</li>
<li>A model of the game itself: paddles, ball, score, etc. Without a model of the game we would have nothing to update or display! These models are the basis for the next two sections. They hold all of the information about Pong that we will need.</li>
</ul></li>
<li><strong>Update:</strong> When new inputs come in, we need to update the game. Without updates, this version of Pong would be very very boring! This section defines a number of 'step functions' that step the game forward based on our inputs. By separating this from the model and display code, we can change how the game works (how it steps forward) without changing anything else: the underlying model and the display code need not be touched.</li>
<li><strong>View:</strong> Finally, we need a display function that defines the user's view of the game. This code is completely separate from the game logic, so it can be modified without affecting any other part of the program. We can also define many different views of the same underlying model. In Pong there is not much need for this, but as your model becomes more complex this may be very useful!</li>
</ol>
<p>If you would like to make a game or larger application in Elm, use this structure! I provide both <a href="https://github.com/evancz/Elm/tree/master/Examples/elm-js/Pong" title="Pong Source Code">the source code for Pong</a> and <a href="https://github.com/evancz/Elm/tree/master/Examples/elm-js/GameSkeleton" title="Game Skeleton">an empty skeleton for game creation</a> which can both be a starting point for playing around with your own ideas.</p>
<p>Let's get into the code!</p>
<h1 id="programming-pong">Programming Pong</h1>
<p>First we have the ever exciting module declaration. We are about to name our module <code>Pong</code>. Whoo!</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Pong</span> <span class="kw">where</span></code></pre>
<p>Next we set our desired frames-per-second (FPS). We'll shoot for 50 FPS. The <code>fps</code> function produces a sequence of time deltas in milliseconds indicating how much time has passed since the previous frame. We then convert those time deltas into seconds so that it is nicer to think about.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">delta <span class="fu">=</span> lift inSeconds (fps <span class="dv">50</span>)</code></pre>
<p>If someone's machine cannot handle 50 FPS, the updates will happen as quickly as possible within the limits of that machine.</p>
<h1 id="section-1-models">Section 1: Models</h1>
<p>Here we will define the data structures that will be used throughout the rest of the program. This is the foundation of our game, so changes here will likely cause changes everywhere else.</p>
<p>These models are a rough specification for your game. They force you to ask: Which features do I want? What information do I need for those features? How do I represent that information? Once you have figured out the core information needed for your game, you have already done a lot of planning about how everything else will work.</p>
<p>Do not be afraid to spend a lot of time thinking about this!</p>
<h2 id="modelling-user-input">Modelling User Input</h2>
<p>During gameplay, all keyboard input is about the position of the two paddles. So the keyboard input can be reduced to two directions, each represented by an integer in {-1,0,1}. Furthermore, the SPACE key is used to start the game between rounds, so we also need a boolean value to represent whether it is pressed.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">KeyInput</span> <span class="fu">=</span> <span class="dt">KeyInput</span> <span class="dt">Bool</span> <span class="dt">Int</span> <span class="dt">Int</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">defaultKeyInput <span class="fu">=</span> <span class="dt">KeyInput</span> <span class="kw">False</span> <span class="dv">0</span> <span class="dv">0</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">keyInput <span class="fu">=</span> lift3 <span class="dt">KeyInput</span> Keyboard.space
                          (lift <span class="fu">.</span>y Keyboard.wasd)
                          (lift <span class="fu">.</span>y Keyboard.arrows)</code></pre>
<p>We now have a concise representation of the keyboard input that updates automatically as new key presses occur.</p>
<h2 id="combining-all-inputs">Combining All Inputs</h2>
<p>The inputs to this game include a timestep (which we extracted from JavaScript) and the keyboard input from the users.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Input</span> <span class="fu">=</span> <span class="dt">Input</span> <span class="dt">Float</span> <span class="dt">KeyInput</span></code></pre>
<p>Combine both kinds of inputs and filter out keyboard events. We only want the game to refresh on clock-ticks, not key presses too.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">input <span class="fu">=</span> sampleOn delta (lift2 <span class="dt">Input</span> delta keyInput)</code></pre>
<p>This signal represents <em>all</em> of the input to our game!</p>
<h2 id="modelling-pong-a-state-machine">Modelling Pong / a State Machine</h2>
<p>Now we need to model the actual game.</p>
<p>Pong has two obvious components: the ball and two paddles.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Paddle</span> <span class="fu">=</span> <span class="dt">Paddle</span> <span class="dt">Float</span>                      <span class="co">-- y-position</span>
<span class="kw">data</span> <span class="dt">Ball</span>   <span class="fu">=</span> <span class="dt">Ball</span> (<span class="dt">Float</span>,<span class="dt">Float</span>) (<span class="dt">Float</span>,<span class="dt">Float</span>)  <span class="co">-- position and velocity</span></code></pre>
<p>But we also want to keep track of the current score and whether the ball is currently in play. This will allow us to have rounds of play rather than just having the ball move around continuously.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Score</span> <span class="fu">=</span> <span class="dt">Score</span> <span class="dt">Int</span> <span class="dt">Int</span>
<span class="kw">data</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Play</span> <span class="fu">|</span> <span class="dt">BetweenRounds</span></code></pre>
<p>Together, this information makes up the state of the game.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GameState</span> <span class="fu">=</span> <span class="dt">GameState</span> <span class="dt">State</span> <span class="dt">Score</span> <span class="dt">Ball</span> <span class="dt">Paddle</span> <span class="dt">Paddle</span></code></pre>
<p>This is the core information needed to step from one frame to the next. If you know these facts and have some user input, you know what the next frame should be.</p>
<p>There is other information that is not specific to a particular frame, like the size of our game. It is safe to define these things separately.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">gameWidth  <span class="fu">=</span> <span class="dv">600</span>
gameHeight <span class="fu">=</span> <span class="dv">400</span>
halfWidth  <span class="fu">=</span> gameWidth  <span class="fu">/</span> <span class="dv">2</span>
halfHeight <span class="fu">=</span> gameHeight <span class="fu">/</span> <span class="dv">2</span></code></pre>
<p>Before we can update anything, we must first define the default configuration of the game. In our case we want to start between rounds with a score of zero to zero.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">defaultGame <span class="fu">=</span> <span class="dt">GameState</span> <span class="dt">BetweenRounds</span>
                        (<span class="dt">Score</span> <span class="dv">0</span> <span class="dv">0</span>)
                        (<span class="dt">Ball</span> (halfWidth, halfHeight) (<span class="dv">150</span>,<span class="dv">150</span>))
                        (<span class="dt">Paddle</span> halfHeight)
                        (<span class="dt">Paddle</span> halfHeight)</code></pre>
<p>We now how a full model of Pong and its inputs!</p>
<h1 id="section-2-update">Section 2: Update</h1>
<p>Our <code>GameState</code> data structure holds all of the information needed to represent the game at any moment. In this section we will define a 'step function' that steps from <code>GameState</code> to <code>GameState</code>, moving the game forward as new inputs come in.</p>
<p>You can think of our game as a finite state machine. Here we are defining a transition function that takes an input and a state, and then steps to the <em>next</em> state. If you are not familiar with finite state machines, do not worry about this analogy!</p>
<h2 id="stepping-from-state-to-state">Stepping from State to State</h2>
<p>To make our step function more managable, we can break it up into smaller components.</p>
<p>First, we define a step function for updating the position of paddles. It only depends on our timestep and a desired direction (given by keyboard input).</p>
<p>We use the <code>clamp</code> function to keep the paddle within the boundaries of the game. The distance moved is determined in part by <code>delta</code>, the time since the last update. This will make the motion of the paddles look smooth even if updates happen irregularly.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">stepPaddle delta dir (<span class="dt">Paddle</span> y) <span class="fu">=</span>
  <span class="dt">Paddle</span> <span class="fu">$</span> clamp <span class="dv">20</span> (gameHeight<span class="dv">-20</span>) (y <span class="fu">-</span> dir <span class="fu">*</span> <span class="dv">200</span> <span class="fu">*</span> delta)</code></pre>
<p>Before we define <code>stepBall</code> we want a couple helper functions to help detect collisions, a surprisingly tricky task, even in Pong.</p>
<p>Since updates may not happen regularly, the ball may move different distances for each update. So imagine that the ball moves into the paddle with a particularly large step. We want to reverse its velocity! So <code>vx = -vx</code>, right? But what if the ball moves out of the paddle with a small step. A step so small that it does not actually make it all the way. That is another collision and we reverse the velocity again! Now we are back where we started! The ball is 'stuck' in a collision.</p>
<p>To be extra careful, we use the <code>makePositive</code> and <code>makeNegative</code> functions to change the velocity of the ball when it hits a wall or paddle. We also use the <code>within</code> function to figure out if <code>x</code> is within <code>epsilon</code> of the number <code>n</code>, helping to detect collisions in the first place.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">makePositive n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> n <span class="kw">else</span> <span class="dv">0</span><span class="fu">-</span>n
makeNegative n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span><span class="fu">-</span>n <span class="kw">else</span> n
within epsilon n x <span class="fu">=</span> x <span class="fu">&gt;</span> n <span class="fu">-</span> epsilon <span class="fu">&amp;&amp;</span> x <span class="fu">&lt;</span> n <span class="fu">+</span> epsilon</code></pre>
<p>The <code>stepVelocity</code> function is used to reverse the velocity of the ball when it has collided with a lower or upper boundary. Notice that the collisions set the direction of the velocity rather than simply negating it!</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">stepVelocity velocity lowerCollision upperCollision <span class="fu">=</span>
 <span class="kw">if</span> <span class="fu">|</span> lowerCollision <span class="ot">-&gt;</span> makePositive velocity
    <span class="fu">|</span> upperCollision <span class="ot">-&gt;</span> makeNegative velocity
    <span class="fu">|</span> <span class="fu">otherwise</span>      <span class="ot">-&gt;</span> velocity</code></pre>
<p>Now that we have a bunch of helper functions, we will actually step the ball forward. The <code>stepBall</code> function first figures out the new velocity of the ball. The velocity only changes when there is a collision with a paddle or a wall. More specifically, the x-velocity depends on paddle collisions, and the y-velocity depends on wall collisions. This new velocity is then used to calculate a new position.</p>
<p>This function also determines whether a point has been scored and who receives the point. Thus, its output is a new Ball and points to be added to each player.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">stepBall delta (<span class="dt">Ball</span> (x,y) (vx,vy)) (<span class="dt">Paddle</span> y1) (<span class="dt">Paddle</span> y2) <span class="fu">=</span>
  <span class="kw">let</span> hitPaddle1 <span class="fu">=</span> within <span class="dv">20</span> y1 y <span class="fu">&amp;&amp;</span> within <span class="dv">8</span> <span class="dv">25</span> x
      hitPaddle2 <span class="fu">=</span> within <span class="dv">20</span> y2 y <span class="fu">&amp;&amp;</span> within <span class="dv">8</span> (gameWidth <span class="fu">-</span> <span class="dv">25</span>) x
      vx&#39; <span class="fu">=</span> stepVelocity vx hitPaddle1 hitPaddle2
      vy&#39; <span class="fu">=</span> stepVelocity vy (y <span class="fu">&lt;</span> <span class="dv">7</span>) (y <span class="fu">&gt;</span> gameHeight <span class="fu">-</span> <span class="dv">7</span>)
      scored <span class="fu">=</span> x <span class="fu">&gt;</span> gameWidth <span class="fu">||</span> x <span class="fu">&lt;</span> <span class="dv">0</span>
      x&#39; <span class="fu">=</span> <span class="kw">if</span> scored <span class="kw">then</span> halfWidth  <span class="kw">else</span> x <span class="fu">+</span> vx&#39; <span class="fu">*</span> delta
      y&#39; <span class="fu">=</span> <span class="kw">if</span> scored <span class="kw">then</span> halfHeight <span class="kw">else</span> y <span class="fu">+</span> vy&#39; <span class="fu">*</span> delta
  <span class="kw">in</span>  ( <span class="dt">Ball</span> (x&#39;,y&#39;) (vx&#39;,vy&#39;)
      , <span class="kw">if</span> x <span class="fu">&gt;</span> gameWidth <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>
      , <span class="kw">if</span> x <span class="fu">&lt;</span> <span class="dv">0</span>         <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span> )</code></pre>
<p>Finally, we define a step function for the entire game. This steps from state to state based on the inputs to the game.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">stepGame (<span class="dt">Input</span> delta (<span class="dt">KeyInput</span> space dir1 dir2))
         (<span class="dt">GameState</span> state (<span class="dt">Score</span> s1 s2) ball paddle1 paddle2) <span class="fu">=</span>
  <span class="kw">let</span> (ball&#39;,s1&#39;,s2&#39;) <span class="fu">=</span> <span class="kw">if</span> state <span class="fu">==</span> <span class="dt">Play</span> <span class="kw">then</span> stepBall delta ball paddle1 paddle2
                                         <span class="kw">else</span> (ball, <span class="dv">0</span>, <span class="dv">0</span>)
      state&#39; <span class="fu">=</span> <span class="kw">case</span> state <span class="kw">of</span> <span class="dt">Play</span> <span class="ot">-&gt;</span> <span class="kw">if</span> s1&#39; <span class="fu">/=</span> s2&#39; <span class="kw">then</span> <span class="dt">BetweenRounds</span> <span class="kw">else</span> state
                             <span class="dt">BetweenRounds</span> <span class="ot">-&gt;</span> <span class="kw">if</span> space <span class="kw">then</span> <span class="dt">Play</span> <span class="kw">else</span> state
  <span class="kw">in</span>  <span class="dt">GameState</span> state&#39;
                (<span class="dt">Score</span> (s1<span class="fu">+</span>s1&#39;) (s2<span class="fu">+</span>s2&#39;))
                ball&#39;
                (stepPaddle delta dir1 paddle1)
                (stepPaddle delta dir2 paddle2)</code></pre>
<p>Now we put everything together. We combine the input, game representation, and step function into one signal.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">gameState <span class="fu">=</span> foldp stepGame defaultGame input</code></pre>
<p>The <code>gameState</code> signal carries the current state of the game. It starts with our default game and steps forward based on user input. All we need to do now is show the game to the user.</p>
<h1 id="section-3-view">Section 3: View</h1>
<p>These functions take a GameState and turn it into something a user can see and understand. It is entirely independent of how the game updates, it only needs to know the current game state. This allows us to change how the game looks without changing any of the logic of the game.</p>
<p>This section gives you much more freedom than the previous ones because you can be as fancy and elaborate as you want. I will try to keep our display fairly simple for the sake of clarity!</p>
<p>The <code>scoreBoard</code> function displays the current score and some directions for the users. When the game is between rounds, this will display a message to users &quot;Press SPACE to begin&quot;, letting them know how to start playing. This message disappears when the ball is in play because it is irrelevant at that point. The score is always displayed.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">scoreBoard w inPlay p1 p2 <span class="fu">=</span>
  <span class="kw">let</span> code <span class="fu">=</span> text <span class="fu">.</span> monospace <span class="fu">.</span> toText
      stack top bottom <span class="fu">=</span> flow down [ code <span class="st">&quot; &quot;</span>, code top, code bottom ]
      msg <span class="fu">=</span> width w <span class="fu">.</span> centeredText <span class="fu">.</span> monospace <span class="fu">$</span> toText <span class="st">&quot;Press SPACE to begin&quot;</span>
      score <span class="fu">=</span> width w <span class="fu">.</span> box <span class="dv">2</span> <span class="fu">$</span> flow right
                [ stack <span class="st">&quot;W&quot;</span> <span class="st">&quot;S&quot;</span>, rectangle <span class="dv">20</span> <span class="dv">1</span>
                , text <span class="fu">.</span> Text.height <span class="dv">4</span> <span class="fu">$</span> <span class="fu">show</span> p1 <span class="fu">++</span> toText <span class="st">&quot;    &quot;</span> <span class="fu">++</span> <span class="fu">show</span> p2
                , rectangle <span class="dv">20</span> <span class="dv">1</span>, stack <span class="st">&quot;&amp;uarr;&quot;</span> <span class="st">&quot;&amp;darr;&quot;</span> ]
  <span class="kw">in</span>  <span class="kw">if</span> inPlay <span class="kw">then</span> score <span class="kw">else</span> score <span class="ot">`above`</span> msg</code></pre>
<p>This function displays the entire GameState. Part of that is the score board, but the most vital part is the display of the game. This uses Elm's <code>collage</code> interface to draw shapes on screen. We just need to draw four things: a field, a ball, the left paddle, and the right paddle.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">display (w,h) (<span class="dt">GameState</span> state (<span class="dt">Score</span> p1 p2) (<span class="dt">Ball</span> pos _) (<span class="dt">Paddle</span> y1) (<span class="dt">Paddle</span> y2)) <span class="fu">=</span>
  layers
    [ scoreBoard w (state <span class="fu">==</span> <span class="dt">Play</span>) p1 p2
    , <span class="kw">let</span> pongGreen <span class="fu">=</span> rgb <span class="dv">60</span> <span class="dv">100</span> <span class="dv">60</span> <span class="kw">in</span>
      size w h <span class="fu">.</span> box <span class="dv">5</span> <span class="fu">$</span> collage gameWidth gameHeight
        [ filled pongGreen (rect gameWidth gameHeight (halfWidth,halfHeight))
        , filled white (oval <span class="dv">15</span> <span class="dv">15</span> pos)                    <span class="co">-- ball</span>
        , filled white (rect <span class="dv">10</span> <span class="dv">40</span> (            <span class="dv">20</span>, y1))   <span class="co">-- first paddle</span>
        , filled white (rect <span class="dv">10</span> <span class="dv">40</span> (gameWidth <span class="fu">-</span> <span class="dv">20</span>, y2))   <span class="co">-- second paddle</span>
        ]
    ]</code></pre>
<p>We can now define a view of the game (a signal of Elements) that changes as the GameState changes. This is what the users will see.</p>
<p>And finally, we display the view of the game to the user!</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">main <span class="fu">=</span> lift2 display Window.dimensions gameState</code></pre>
<p>And that is it! <a href="http://elm-lang.org/blog/games-in-elm/part-0/Pong.html">Pong in Elm</a>!</p>
<h1 id="post-script">Post Script</h1>
<h2 id="learn-by-doing-programming-challenges">Learn by Doing: Programming Challenges</h2>
<p>If you want to learn more about making games in Elm, try tackling some of these challenges:</p>
<ul>
<li>Make the Pong field look nicer. Add a line (or dotted line) at mid-field.</li>
<li>Add the ability to pause the game during game play.</li>
<li>Add the ability to reset the game (besides refreshing the page!)</li>
<li>Make ball collisions more complicated. Possiblities:
<ul>
<li>When the ball hits the corner of a paddle, it changes direction.</li>
<li>If the ball hits a moving paddle, it adds spin to the ball, making it rebound in a different direction.</li>
</ul></li>
<li>Add a second ball to the game.</li>
<li>Write a simple AI for a paddle. A simple strategy is to always put the paddle at the same y height as the ball, but this is not very fun to play against. Maybe try an AI that is not so smart to make things more interesting.</li>
</ul>
<h2 id="further-reading">Further Reading</h2>
<p>If you want to read more about FRP for games, see <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf">this paper</a>. Note that it is specific to Arrowized FRP, which is supported by Elm's <a href="http://elm-lang.org/docs/Automaton.elm">Automaton library</a>.</p>
</div>
</body>
</html>
